## 1. 文档目标与适用范围

本文件规定汽车诊断软件项目的**技术选型原则**，重点覆盖：

- 前端（UI）技术栈的选型标准（由 `platform` 团队负责实现，本文件只给出约束与期望）；
- 后端 / 业务逻辑层（本 agent 负责的 C++ 代码）技术栈约束；
- 嵌入式通讯库 / 车辆通信栈（包括 RP1210 等）的选型和使用原则；
- 第三方依赖（含开源库）的引入、版本管理与 License 合规策略。

本文件需与 `diagnostic_rules/architecture.md` 保持一致，当发生冲突时以上位文档为准。

---

## 2. 总体技术选型原则

1. **稳定优先**  
   - 优先选择在业界大量实践验证、维护活跃、文档完善的技术栈；
   - 避免选用实验性、维护不活跃或版本频繁破坏兼容的框架。

2. **长期维护性优先**  
   - 技术选型必须考虑 **5–10 年生命周期** 内的维护成本；
   - 尽量减少不同车系间的技术栈差异，避免为少量差异引入全新技术。

3. **最小依赖原则**  
   - 优先使用 **C++ 标准库** 与 `platform` 提供的能力；
   - 仅在明确收益（显著降低工作量/风险）且无现有替代的情况下，引入新的第三方库。

4. **License 合规与静态链接风险控制**  
   - 所有第三方依赖（含测试框架）必须进行 License 审查；
   - 在静态链接场景下，严禁引入可能导致软件整体 License 受限的库（如 GPL/AGPL）。

5. **与 platform 的边界清晰**  
   - UI 框架、通信基础库、JSON 库由 `platform` 提供；
   - 车系工程 `HD_<Carline>` 不得自行引入与 `platform` 职责重叠的框架。

---

## 3. 语言与编译工具链选型

### 3.1 语言与标准版本

1. **统一使用 C++14**  
   - **选型**：所有业务逻辑代码必须以 **C++14** 标准编译和开发。
   - **约束**：禁止使用 C++17 及以上特性（如结构化绑定、`if constexpr` 等），以确保在旧版编译器上的兼容性。

2. **异常机制约束（No Exceptions）**
   - **选型**：**禁用 C++ 异常机制**。
   - **原因**：受限于 `platform` 环境及嵌入式安全要求。
   - **落地**：具体错误处理设计模式（如 `Result<T>`）请严格遵循 `architecture.md` 中的“7.1 语言与异常约束”章节。

### 3.2 编译器与编译选项（原则）

> 实际编译器可能由公司统一规范，本处给出选型与配置方向。

1. 编译器选型应满足：
   - 对 C++14 支持成熟；
   - 有良好的诊断信息（警告提示清晰）；
   - 在目标操作系统（通常为 PC 诊断环境，如 Windows）上广泛使用。

2. 编译选项建议：
   - 打开尽量多的警告等级，并将关键警告视为错误（如 MSVC `/W4 /WX`、GCC/Clang `-Wall -Wextra -Werror` 等）；
   - 开启优化选项时（如 `-O2`），须通过测试验证时间敏感路径行为稳定。

---

## 4. 前端（UI）技术栈选型原则

> **注意**：UI 由 `platform` 工程负责实现，本 agent 不直接开发 UI。本节仅作为背景信息。

1. **选型责任**：前端框架选型完全由 `platform` 团队负责（如 Qt / WPF / WinUI 等）。
2. **集成约束**：诊断业务 UI 仅通过 `platform/inc` 暴露的接口与车系业务通讯。`HD_<Carline>` 代码不得依赖具体 UI 框架的头文件或库。

---

## 5. 后端 / 业务逻辑技术栈选型（本 agent 主要职责）

### 5.1 语言与标准库

1. **标准库优先**
   - 日志、字符串处理、容器、算法优先使用 C++ 标准库；
   - 禁止仅为简单功能（如字符串分割、简单 JSON 包装）而引入重量级库。

2. **禁止滥用大型通用库**
   - 默认禁止引入 **Boost** 等大型通用库；
   - 如确有必要（解决复杂问题且收益巨大），必须经过技术评审和 License 审核。

### 5.2 内部基础设施封装

1. **运行时服务**（日志、时间、线程、网络）：
   - 优先通过 `platform` 提供的接口。
   - 如需自行实现，必须封装在 `infrastructure` 模块。

2. **JSON 处理**：
   - **选型**：必须使用 `platform` 提供的 JSON 库。
   - **约束**：业务层不要直接操作 JSON 节点对象，详细集成规范见 `architecture.md`。

### 5.3 单元测试框架（如引入）

> 单元测试框架原则上不参与交付产物静态链接，可放宽部分 License 约束，但仍需统一管理。

1. **测试框架选型标准**：
   - 易用、文档齐全、活跃维护；
   - 编译和链接开销可接受；
   - License 友好（MIT/BSD/Apache 2.0 优先）。

2. **示例**：
   - `GoogleTest`、`Catch2` 等（具体采用需在项目层面决策）。

---

## 6. 嵌入式通讯库与 ECU 通信栈选型原则

### 6.1 通信栈总体原则

1. **底层通信**（CAN、DoIP、J1939 等）：
   - 由 `platform` 提供，车系业务代码不直接选型或实现。

2. **诊断协议**（UDS / KWP2000 / OBD-II 等）：
   - 协议实现优先使用 `platform` 或公共模块。
   - 车系层只负责业务流程（见 `diagnostic_rules/domain_standards.md`）。

### 6.2 RP1210 驱动与动态加载

1. **RP1210 技术选型**
   - **选型**：使用 **供应商提供的 RP1210 驱动库**（通常为 DLL/SO），不自行实现 RP1210 协议栈。
   - **使用方式**：必须通过操作系统 API（如 `LoadLibrary` / `GetProcAddress`）进行 **动态加载**，禁止静态链接。

2. **架构落地**
   - 关于如何在代码中实现动态加载的隔离与抽象，请参阅 `architecture.md` 中的“8. RP1210 动态加载架构原则”。

### 6.3 其他通信依赖库

1. 如需与其他专有硬件或网关库集成：
   - 统一遵循与 RP1210 相同的原则：动态加载、隔离抽象、License 合规。

2. 在引入新的通信类依赖前，必须确认 `platform` 无现成支持且确有必要。

---

## 7. 数据存储与配置格式选型

> 具体读写实现规范见 `architecture.md` (data_access 层) 和相关数据文档。

1. **配置类数据**
   - 推荐：INI / JSON。
   - 约束：若使用 JSON，必须依赖 `platform` JSON 库。

2. **结构化数据 / 历史记录**
   - 推荐：轻量级嵌入式数据库（如 SQLite），需通过 License 审核。
   - 约束：访问逻辑必须集中在 `data_access` 层。

3. **二进制数据**
   - 推荐：自定义 bin 格式或 OEM 指定格式。
   - 约束：需包含版本号和校验机制。

---

## 8. 第三方依赖管理策略

### 8.1 引入流程

引入任何新的第三方库（包含开源与商业库）必须满足：

1. **需求与替代性论证**：确认无 `platform` 或内部替代方案。
2. **技术评估**：版本稳定，文档齐全，社区活跃。
3. **License 审查**：明确 License 类型及对静态链接的要求。
4. **评审与决策记录**：登记依赖信息（名称、版本、License、用途）。

### 8.2 版本管理与升级策略

1. **版本锁定**：显式锁定第三方库的版本。
2. **升级窗口**：非安全问题避免在临近发布前升级；升级需回归测试。
3. **依赖清单（BOM）**：建立统一清单，包含名称、版本、License 等。

---

## 9. License 合规策略

### 9.1 优先与禁止的 License 类型

1. **优先采纳**：MIT、BSD（2/3-Clause）、Apache 2.0 等宽松 License。
2. **谨慎采纳（需评估）**：LGPL、MPL（需确认静态链接和修改义务）。
3. **一般禁止**：GPL、AGPL 等强 Copyleft License（禁止引入至车系项目产物）。

### 9.2 源码与声明管理

1. 在 `THIRD_PARTY` 目录保存 License 声明副本。
2. 在打包文档中列出使用的第三方库。

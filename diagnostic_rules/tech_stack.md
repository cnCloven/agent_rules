## 1. 文档目标与适用范围

本文件规定汽车诊断软件项目的**技术选型原则**，重点覆盖：

- 前端（UI）技术栈的选型标准（由 `platform` 团队负责实现，本文件只给出约束与期望）；
- 后端 / 业务逻辑层（本 agent 负责的 C++ 代码）技术栈约束；
- 嵌入式通讯库 / 车辆通信栈（包括 RP1210 等）的选型和使用原则；
- 第三方依赖（含开源库）的引入、版本管理与 License 合规策略。

本文件需与 `diagnostic_rules/architecture.md` 保持一致，当发生冲突时以上位文档为准。

---

## 2. 总体技术选型原则

1. **稳定优先**  
   - 优先选择在业界大量实践验证、维护活跃、文档完善的技术栈；
   - 避免选用实验性、维护不活跃或版本频繁破坏兼容的框架。

2. **长期维护性优先**  
   - 技术选型必须考虑 **5–10 年生命周期** 内的维护成本；
   - 尽量减少不同车系间的技术栈差异，避免为少量差异引入全新技术。

3. **最小依赖原则**  
   - 优先使用 **C++ 标准库** 与 `platform` 提供的能力；
   - 仅在明确收益（显著降低工作量/风险）且无现有替代的情况下，引入新的第三方库。

4. **License 合规与静态链接风险控制**  
   - 所有第三方依赖（含测试框架）必须进行 License 审查；
   - 在静态链接场景下，严禁引入可能导致软件整体 License 受限的库（如 GPL/AGPL）。

5. **与 platform 的边界清晰**  
   - UI 框架、通信基础库、JSON 库由 `platform` 提供；
   - 车系工程 `HD_<Carline>` 不得自行引入与 `platform` 职责重叠的框架。

---

## 3. 语言与编译工具链选型

### 3.1 语言与标准版本

1. **统一使用 C++14**  
   - 所有业务逻辑代码以 **C++14** 为准；
   - 禁止使用 C++17 及以上特性（如结构化绑定、`if constexpr` 等）。

2. **异常机制约束**
   - 受限于 `platform` 不支持异常处理：
     - 业务代码中禁止使用 `throw`、`try`、`catch`；
     - 设计必须基于 **返回码 / 结果类型** 的错误传播模式。

### 3.2 编译器与编译选项（原则）

> 实际编译器可能由公司统一规范，本处给出选型与配置方向。

1. 编译器选型应满足：
   - 对 C++14 支持成熟；
   - 有良好的诊断信息（警告提示清晰）；
   - 在目标操作系统（通常为 PC 诊断环境，如 Windows）上广泛使用。

2. 编译选项建议：
   - 打开尽量多的警告等级，并将关键警告视为错误（如 MSVC `/W4 /WX`、GCC/Clang `-Wall -Wextra -Werror` 等）；
   - 开启优化选项时（如 `-O2`），须通过测试验证时间敏感路径行为稳定。

---

## 4. 前端（UI）技术栈选型原则

> 说明：UI 由 `platform` 工程负责实现，本 agent 不直接开发 UI。  
> 本节为全局标准与对 `platform` 的约束期望，不指导 `HD_<Carline>` 中自行引入 UI 框架。

1. **统一入口与抽象**
   - 诊断业务 UI 仅通过 `platform/inc` 暴露的接口与车系业务通讯；
   - 禁止在 `HD_<Carline>/code` 中直接包含任何 UI 框架头文件。

2. **前端框架选型标准（由 platform 团队执行）**
   - 必须具备：
     - 跨版本兼容性稳定；
     - 国际化、本地化支持能力；
     - 足够的组件库支持复杂诊断界面（树状、表格、图表、日志区域等）。
   - 鼓励选用：
     - 在 PC 诊断行业广泛使用的成熟框架（如 Qt / WPF / WinUI 等，具体由公司统一决定）；
   - UI 技术更迭不应影响 `HD_<Carline>` 业务逻辑代码的接口契约。

3. **UI 与业务逻辑关系**
   - UI 层通过 `platform` 暴露的接口调用业务逻辑（例如“开始诊断”“停止刷写”）；
   - 业务逻辑对 UI 完全无感，仅暴露状态/结果，由 `platform` 负责展示。

---

## 5. 后端 / 业务逻辑技术栈选型（本 agent 主要职责）

### 5.1 语言与标准库

1. **标准库优先**
   - 日志、字符串处理、容器、算法优先使用 C++ 标准库；
   - 禁止仅为简单功能（如字符串分割、简单 JSON 包装）而引入重量级库。

2. **禁止滥用大型通用库**
   - 默认禁止引入 **Boost** 等大型通用库；
   - 如确有必要（解决复杂问题且收益巨大），必须经过：
     - 技术评审；
     - License 审核；
     - 明确限制使用范围与依赖子集。

### 5.2 内部基础设施封装

1. 日志、时间、线程、网络等运行时服务：
   - 优先通过 `platform` 提供的接口；
   - 如 `platform` 未提供且必须在车系层实现：
     - 需要封装在 `infrastructure` 模块，暴露统一接口，避免上层直接依赖系统 API。

2. JSON 处理：
   - 必须使用 `platform` 提供的 JSON 库；
   - 业务层不要直接操作 JSON 节点对象，而是通过：
     - `data_access` 层将 JSON 转换为领域模型；
     - 避免将 JSON 类型作为公共接口签名的一部分。

### 5.3 单元测试框架（如引入）

> 单元测试框架原则上不参与交付产物静态链接，可放宽部分 License 约束，但仍需统一管理。

1. 测试框架选型标准：
   - 易用、文档齐全、活跃维护；
   - 编译和链接开销可接受；
   - License 友好（MIT/BSD/Apache 2.0 优先）。

2. 示例：
   - `GoogleTest`、`Catch2` 等（具体采用需在项目层面决策）。

---

## 6. 嵌入式通讯库与 ECU 通信栈选型原则

### 6.1 通信栈总体原则

1. 底层通信（CAN、DoIP、J1939 等）由 `platform` 提供：
   - 车系业务代码不直接选型、实现底层协议栈；
   - 只能通过 `platform/inc` 中暴露的接口或适配层调用通信能力。

2. 对诊断协议（UDS / KWP2000 / OBD-II 等）：
   - 协议具体实现逻辑 **优先在 platform 或公共模块中提供**；
   - 车系层只负责在协议之上实现业务流程和规则（见 `diagnostic_rules/domain_standards.md`）。

### 6.2 RP1210 驱动与动态加载

1. **RP1210 技术选型**
   - 使用 **供应商提供的 RP1210 驱动库**，不自行实现或替代；
   - 将 RP1210 视为“第三方专用驱动”，仅通过统一的 `rp1210_loader` 模块动态访问。

2. **动态加载方式**
   - 必须通过操作系统 API（如 `LoadLibrary` / `GetProcAddress` 等）进行 **动态加载**；
   - 禁止将 RP1210 库静态链接进 `HD_<Carline>`，减少与特定设备的强绑定。

3. **抽象与隔离**
   - 在 `infrastructure` 层定义统一抽象（如 `IRp1210Channel`、`IRp1210DeviceManager`）；
   - 上层业务通过抽象接口使用 RP1210，不直接依赖具体库函数名/结构体。

### 6.3 其他通信依赖库

1. 如需与其他专有硬件或网关库集成：
   - 统一遵循与 RP1210 相同的原则：
     - 尽量动态加载；
     - 通过 `infrastructure` 层抽象隔离；
     - 检查 License 与分发要求。

2. 在引入新的通信类依赖前，必须确认：
   - `platform` 无现成支持；
   - 该依赖库为车系级或项目级确有必要，而非暂时性实验。

---

## 7. 数据存储与配置格式选型

> 具体读写实现规范见文档规范与 `data_access` 相关规则，本节仅定义技术栈选择原则。

1. **配置类数据**
   - 小规模、简单结构配置（如开关、参数表）：
     - 可优先选择 INI / JSON；
     - 若使用 JSON，必须依赖 `platform` 提供的 JSON 库进行解析。
   - 结构复杂、层级较深的数据：
     - JSON 或专用格式（ODX/OTX 等）；
     - 解析逻辑封装在 `data_access` 层。

2. **结构化数据 / 历史记录**
   - 如需进行查询、统计或持久化历史记录：
     - 鼓励使用轻量级嵌入式数据库（如 SQLite），前提是已通过 License 审核；
     - 所有数据库访问必须集中在 `data_access` 层，避免业务层直接操作 SQL。

3. **二进制数据**
   - ECU 校验文件、刷写包等大二进制对象：
     - 使用自定义 bin 格式或 OEM 指定格式；
     - 注意在设计格式时预留版本号和校验机制。

---

## 8. 第三方依赖管理策略

### 8.1 引入流程

引入任何新的第三方库（包含开源与商业库）必须满足：

1. **需求与替代性论证**
   - 说明用途、带来收益（减少实现工作量、降低风险、提升性能等）；
   - 确认不存在现有 `platform` 或其它内部模块可以替代。

2. **技术评估**
   - 版本稳定性：是否处于长期维护版本；
   - 文档质量：是否有完整 API 文档、示例与迁移指南；
   - 生态与社区：问题响应是否及时，有无已知严重缺陷。

3. **License 审查**
   - 明确 License 类型及对静态链接、再分发的要求；
   - 必要时与法务/合规团队评审。

4. **评审与决策记录**
   - 通过技术评审会议或设计文档记录选型决策；
   - 在项目知识库中登记依赖信息（名称、版本、License、用途）。

### 8.2 版本管理与升级策略

1. **版本锁定**
   - 在项目中显式锁定第三方库的版本（或版本区间），避免构建环境不一致；
   - 生产线打包时，明确记录所使用的库版本。

2. **升级窗口**
   - 非安全问题不在临近量产或重要里程碑前进行大版本升级；
   - 升级前必须：
     - 阅读变更日志；
     - 在测试环境完成回归测试。

3. **依赖清单（BOM）**
   - 建立统一的第三方依赖清单，包含：
     - 名称 / 版本 / License / 使用范围 / 静态或动态链接方式；
   - 便于后续 License 合规审查与安全漏洞排查。

---

## 9. License 合规策略

### 9.1 优先与禁止的 License 类型

1. **优先采纳**
   - MIT、BSD（2/3-Clause）、Apache 2.0 等宽松 License；
   - 允许在闭源商业软件中使用和静态链接，义务主要为保留版权声明与 License 文本。

2. **谨慎采纳（需评估）**
   - LGPL：在静态链接场景下可能要求提供目标文件，需与法务确认；
   - MPL：对修改过的文件有开源义务，需要确认边界。

3. **一般禁止**
   - GPL、AGPL 等强 Copyleft License：
     - 在静态链接和整体分发场景下，可能要求整个软件开源；
     - 原则上不允许引入至车系项目的产物中。

### 9.2 源码与声明管理

1. 所有三方库必须：
   - 在项目 `THIRD_PARTY` 或类似目录保存 License 声明副本；
   - 在打包文档中列出所使用第三方库及相应 License。

2. 对部分 OEM 或协议标准附属的实现（如 ODX/OTX 工具库）：
   - 需额外确认其分发权限与商用限制。

---

## 10. 对本 agent 的具体执行要求

1. 在为 `HD_<Carline>/code` 生成或修改代码时，你必须：
   - 仅使用 C++14 语言特性；
   - 避免使用异常处理机制；
   - 不主动引入新的第三方库（除非用户明确指示并已说明合规性）。

2. 当用户请求使用某个特定库 / 框架时，你应：
   - 先根据本文件原则进行简要合规性与合理性评估（成熟度、License、大型依赖等）；
   - 明确指出潜在风险（特别是 License 与静态链接相关）；
   - 如用户坚持使用，在回答中遵循其选型，同时保留风险提示。

3. 如果设计建议中涉及 UI 或底层通信栈：
   - 必须明确说明“由 `platform` 团队负责具体选型与实现”，
   - 仅从接口抽象与集成角度给出建议，不在车系工程中直接选用 UI/通信框架。

本技术选型指南在实际项目中如需调整，必须通过架构评审，并同步更新文档与依赖清单。

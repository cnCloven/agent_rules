## 1. 文档目标与适用范围

本文件定义用于**汽车诊断软件车系工程（如 HD_BEIQI）业务逻辑层的架构设计原则**，重点约束：

- 高内聚、低耦合的模块划分；
- 分层架构与依赖方向；
- 插件化 / 可扩展设计（特别是车系、车型、功能扩展）；
- 针对汽车诊断场景的实时性与稳定性要求；
- 在 **C++14、无异常处理（无 try/catch）**、依赖 `platform` 项目的前提下的具体约束；
- **动态加载 RP1210** 的专用架构要求。

本原则仅适用于：

- `HD_<Carline>/code` 与 `HD_<Carline>/data` 下的业务实现；
- 使用 `platform/inc` 暴露的接口、`platform/lib` 静态库进行链接的场景。

UI 框架、通信底层实现、JSON 库实现等均由 `platform` 提供，本文件不约束其内部实现，只约束如何在车系工程中**以合理方式使用**。

---

## 2. 系统边界与目录结构约束

### 2.1 顶层物理目录

```text
ROOT
├─ platform
│  ├─ inc       # 平台提供的所有接口头文件
│  └─ lib       # 平台提供的静态库实现（需静态链接）
└─ HD_<Carline>
   ├─ code      # 车系业务逻辑 C++ 代码
   └─ data      # 车系数据文件（bin / ini / sql 等）
```

约束：

1. `platform`  
   - 由其他部门维护，**禁止**修改其目录结构和内容；
   - 车系工程只能：
     - `#include "platform/inc/..."` 中的头文件；
     - 链接 `platform/lib` 中的静态库。

2. `HD_<Carline>`  
   - 车系工程目录命名必须为 `HD_` + 车系名称（如 `HD_BEIQI`），  
     **不得自行创建新车系目录名称**，必须由用户指定；
   - 本 agent 只在 `HD_<Carline>/code` 与 `HD_<Carline>/data` 中生成和修改文件。

3. 责任边界  
   - 本 agent 只负责 **C++ 业务逻辑实现**：
     - 诊断策略、流程控制、数据解析与转换、与 UI/通信接口的业务层对接等；
   - **禁止**：
     - 编写或修改 UI 框架代码；
     - 自行实现底层通信协议栈（CAN/UDS/DoIP 等）；
     - 引入或实现与 `platform` 已提供功能重复的基础设施。

### 2.2 `HD_<Carline>/code` 内部逻辑分层（建议结构）

建议在 `HD_<Carline>/code` 下采用逻辑分层，以便清晰控制依赖方向（即可维护性）：

```text
HD_<Carline>/code
├─ app/              # 应用层：用例流程、任务编排、与 UI/平台交互的入口
├─ domain/           # 领域层：诊断业务模型与核心规则
├─ infrastructure/   # 基础设施层：对 platform / RP1210 / 文件等的适配
└─ data_access/      # 数据访问层：对 data/ 的读写（bin/ini/sql 等）
```

依赖方向**必须自上而下**：

- `app` 只能依赖 `domain`、`data_access`、`infrastructure` 暴露的接口；
- `domain` 只能依赖 `data_access` 的抽象接口，**禁止**直接依赖 `platform`；
- `infrastructure` 可以依赖 `platform/inc` 和系统 API（如动态库加载）；
- `data_access` 只负责对 `HD_<Carline>/data` 中数据文件的访问，不应依赖 UI。

---

## 3. 高内聚、低耦合设计原则

### 3.1 模块划分原则

1. **按业务功能划分，而非技术细节划分**  
   - 每个模块应围绕一个清晰的业务能力，例如：
     - `DtcService`（故障码读取/清除）；
     - `EcuCodingService`（编码/配置写入）；
     - `FlashProgrammingService`（刷写）；
   - 禁止出现“万能工具类”模块（如 `Util` 大杂烩），应按业务职责重新拆分。

2. **单一职责**  
   - 一个类 / 模块应有单一逻辑原因导致其变化；
   - 例如：诊断流程控制与UI展现逻辑必须解耦：
     - 业务层只暴露“开始诊断/停止诊断/获取结果”的接口；
     - UI 如何展示进度和结果由 `platform` UI 框架负责。

3. **业务逻辑独立于平台细节**  
   - 业务模块（`domain`）必须：
     - 不直接包含 `platform/inc` 头文件；
     - 通过在 `infrastructure` 层定义的抽象接口（如 `IDiagTransport`, `ILogService`）间接使用平台能力。

### 3.2 耦合控制原则

1. **面向接口编程**  
   - 框架向上暴露稳定接口，例如：
     - `IDiagnosticUseCase`；
     - `IEcuSessionManager`；
   - 向下依赖抽象（接口或纯虚基类），避免上层直接依赖具体实现类。

2. **禁止横向依赖**  
   - 不同业务模块间（如 DTC、刷写、编码）原则上只通过 **明确的公共接口** 交互；
   - 禁止在模块内部直接 `#include` 其他模块的内部实现头文件。

3. **限制跨层访问**  
   - 上层不能跳过中间层去直接依赖底层实现：
     - `app` 不得直接调用 RP1210 加载细节；
     - 必须通过 `infrastructure` 层定义的抽象设备接口。

---

## 4. 分层架构原则

### 4.1 层次定义

1. **应用层（app）**
   - 职责：
     - 将用户操作（来自 UI）映射到诊断用例；
     - 管理诊断任务的生命周期（开始 / 停止 / 暂停 / 超时）；
     - 编排多个业务模块（DTC、数据流、刷写等）的执行顺序。
   - 约束：
     - 不包含具体诊断协议细节；
     - 不直接操作数据文件或硬件接口。

2. **领域层（domain）**
   - 职责：
     - 定义核心业务对象（ECU、DTC、服务、会话状态等）；
     - 实现诊断规则与状态机；
     - 对上提供与具体 UI 和平台无关的业务接口。
   - 约束：
     - 不依赖 `platform/inc`；
     - 与具体车辆型号差异相关的参数尽量通过 `data` 配置而不是硬编码。

3. **基础设施层（infrastructure）**
   - 职责：
     - 封装 `platform` 能力（通信、UI 通知、日志、JSON 等）为内部可替换接口；
     - 实现 RP1210 动态加载与适配；
     - 文件系统访问、时间/计时、线程等操作系统相关功能。
   - 约束：
     - 对上暴露接口（例如 `IDiagTransport`），对下调用 `platform/inc` 及系统 API；
     - RP1210 动态加载逻辑必须在**单独的代码文件**中实现（见第 7 节）。

4. **数据访问层（data_access）**
   - 职责：
     - 负责读取/写入 `HD_<Carline>/data` 中的各种数据文件；
     - 为领域层提供类型化的数据模型（如 ECU 配置、服务脚本、DTC 映射）。
   - 约束：
     - 不处理业务流程，只做数据转换与校验；
     - 接口需考虑数据版本兼容性。

### 4.2 依赖方向与接口原则

- 依赖方向固定为：`app → domain → (data_access, infrastructure)`；
- 高层仅通过接口感知低层能力：
  - 例如 `domain` 仅依赖 `IDataRepository` 接口，具体实现由 `data_access` 提供；
  - `app` 仅依赖 `IDiagnosticUseCase` 接口，不关心其内部使用哪个通信通道。

---

## 5. 插件化与可扩展性设计

### 5.1 车系与车型扩展

1. **车系级隔离**
   - 每个车系使用单独工程目录 `HD_<Carline>`；
   - 本 agent **不得在未获指示情况下创建新车系目录名称**；
   - 共性逻辑优先通过**可配置数据**与**通用业务模块**复用，而不是复制代码。

2. **车型/配置插件化**
   - 不同车型或配置差异（通信参数、服务集、DTC 映射等）必须：
     - 优先通过 `data` 中的配置文件体现；
     - 业务代码中通过统一接口加载和选择对应的配置对象。
   - 禁止为每个车型散落大量 `if (model == X)` 的硬编码逻辑，优先使用：
     - 策略模式（Strategy）；
     - 工厂模式（Factory）+ 配置驱动实例化。

### 5.2 功能扩展插件化

1. **功能模块化**
   - 新诊断功能（如新测试序列、新自检流程）不应修改既有核心模块，而是：
     - 新增业务模块实现既定接口；
     - 通过配置或注册机制将其注入应用层用例。

2. **接口稳定性**
   - 核心接口（如 `IDiagnosticUseCase`, `IDiagTransport`）一经对外使用，应尽量保持向后兼容；
   - 当需要变更时：
     - 通过增加新接口版本（如 `IDiagnosticUseCaseV2`）而非直接修改旧接口破坏兼容；
     - 在实现中保持旧接口可用一段迁移期。

---

## 6. 汽车诊断场景特有约束：实时性与稳定性

### 6.1 实时性要求

1. **响应时间**
   - 与 ECU 通信相关操作必须：
     - 明确超时策略（由配置或平台参数控制）；
     - 不在主控制流程中执行长时间阻塞操作而无进度反馈。
   - 应用层与领域层应优先设计为：
     - 异步或分阶段执行，允许 UI 进行进度显示和中断操作（具体 UI 通过 `platform` 完成）。

2. **时间敏感操作的调度**
   - 对定时发送/周期变量监测等逻辑：
     - 必须为时间关键路径单独建模，不与耗时的数据加载、磁盘 IO 混在同一执行链路；
     - 如需周期执行，应依赖 `platform` 或基础设施提供的定时器服务，而非自建不可靠的轮询架构。

### 6.2 稳定性与故障容错

1. **无异常（try/catch）环境下的健壮性**
   - 由于 `platform` 不支持异常处理：
     - **禁止在业务代码中使用 `throw`、`try`、`catch`**；
     - 函数应通过返回值（如状态码或 `Result<T>` 样式结构）报告错误；
     - 内部错误必须可被上层感知并作出可控处理（如终止当前用例、提示上层逻辑重试）。

2. **对平台/硬件的防御性编程**
   - 与硬件/外设（如 RP1210 设备）交互前必须：
     - 检查句柄/连接是否有效；
     - 校验输入参数合理（如 ID、长度、地址范围）；
     - 对返回值进行完整检查，不忽略错误码。
   - 对任何可能影响 ECU 安全（如刷写、编码）的操作：
     - 必须有明确的步骤状态机和失败恢复策略（如断点恢复/回滚警告）。

3. **不可崩溃原则**
   - 任何来自外部的数据（文件、平台接口、ECU 响应）都视为不可信：
     - 必须校验长度、范围、类型；
     - 一旦异常，优先选择**安全失败**（中止操作并上报错误），而非继续执行不确定行为。

---

## 7. C++14 与平台约束下的架构规则

### 7.1 语言与异常约束

1. **C++14 标准**
   - 所有业务代码应以 C++14 为基准进行设计；
   - 禁止使用高于 C++14 的语言特性（如结构化绑定、`if constexpr` 等）。

2. **无异常策略**
   - 禁止在代码中使用：
     - `throw` 抛出异常；
     - `try` / `catch` 块；
   - 对资源管理：
     - 仍然推荐使用 RAII（智能指针、管理类）；
     - 但析构函数中不得抛出异常。

3. **错误返回模式**
   - 推荐为关键业务函数设计统一的错误返回模式：
     - 如 `enum class ErrorCode` + `struct Result<T> { T value; ErrorCode error; }`；
   - 上层必须检查结果对象中的错误码，不得无视返回值。

### 7.2 与 platform / JSON 的集成

1. **platform 接口使用**
   - 只能包含 `platform/inc` 中公开的头文件；
   - 禁止复制或自行声明平台库中的内部接口；
   - 如需抽象平台能力，必须在 `infrastructure` 层定义适配器类，对外隐藏平台具体类型。

2. **JSON 库使用**
   - 只能使用 `platform` 提供的 JSON 库；
   - 业务层不直接依赖 JSON 类型：
     - 推荐在 `data_access` / `infrastructure` 中将 JSON 解析为领域模型；
     - 上层仅操作 C++ 类型而非 JSON 节点对象。

---

## 8. RP1210 动态加载架构原则

### 8.1 专用模块与文件划分

1. **单独代码文件**
   - 所有 RP1210 相关的：
     - 动态库加载（`LoadLibrary` / `GetProcAddress` 或等效机制）；
     - 函数指针声明与绑定；
     - 初始化与卸载流程；
   - 必须集中在 **单独的 C++ 实现文件和头文件对** 中，例如：
     - `infrastructure/rp1210_loader.h`
     - `infrastructure/rp1210_loader.cpp`

2. **抽象接口隔离**
   - 上层业务不得直接接触 RP1210 函数指针；
   - `rp1210_loader` 模块应对外暴露：
     - 一个抽象的通信接口（如 `IRp1210Channel`）或工厂类；
     - 屏蔽操作系统 API 和具体函数名。

### 8.2 动态加载与故障处理

1. **加载失败处理**
   - 动态库加载失败、函数绑定失败必须：
     - 返回明确的错误码或错误状态；
     - 不得导致程序崩溃；
     - 上层可根据错误选择降级策略（如禁止使用相关设备并提示）。

2. **运行时安全**
   - 在每次调用 RP1210 函数前，必须确保：
     - 相应的函数指针非空；
     - 设备句柄有效；
   - 对 RP1210 返回的错误码进行完整解析与处理，必要时映射到统一的 `ErrorCode`。

3. **资源清理**
   - 设计清晰的生命周期管理：
     - 设备打开/关闭；
     - 动态库加载/卸载；
   - 使用 RAII 封装，确保即便在中途错误返回，也不会泄漏句柄或内存。

---

## 9. 代码与数据分离原则

1. **业务参数配置化**
   - 与具体 ECU / 车型高度相关的常量（如：
     - 地址、会话 ID；
     - 服务子功能号；
     - DTC 映射表；
   ）应尽量放在 `HD_<Carline>/data` 中对应的数据文件中，而非硬编码在 C++ 中。

2. **数据访问接口**
   - 通过 `data_access` 层对外提供：
     - 清晰的加载接口（按车系/车型/功能划分）；
     - 必要的缓存与校验逻辑；
   - 禁止业务模块自行打开文件、解析格式，应统一通过数据访问层封装。

3. **版本与兼容**
   - 数据文件需具备基础的版本字段；
   - 业务逻辑在读取数据时，应检查版本以决定是否兼容或拒绝。

---

## 10. 总体要求

- 任何新设计、新模块必须：
  - 明确其所在层（app / domain / infrastructure / data_access）；
  - 明确其职责边界和上游/下游依赖；
  - 符合“高内聚、低耦合”的基本原则。

- 在实现前，优先从以下角度自查设计是否合理：
  1. 是否将 `platform` 细节封装在 `infrastructure` 层，而非泄漏到业务层；
  2. 是否为车系、车型差异预留了通过 `data` 配置扩展的空间；
  3. 是否考虑了无异常环境下的错误传播与资源安全；
  4. 是否保证未来新增功能时，主要通过新增模块/配置而非大面积修改既有代码。

本文件中的原则为后续详细规范（技术选型、编码规范、测试规范等）的**架构前置约束**，在出现冲突时，本文件的要求优先于下位文件。
